// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSSSSS_PINET_H_
#define FLATBUFFERS_GENERATED_SSSSSS_PINET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace PiNet {

struct Pool;
struct PoolBuilder;
struct PoolT;

struct Conv;
struct ConvBuilder;
struct ConvT;

struct Op;
struct OpBuilder;
struct OpT;

struct Net;
struct NetBuilder;
struct NetT;

bool operator==(const PoolT &lhs, const PoolT &rhs);
bool operator!=(const PoolT &lhs, const PoolT &rhs);
bool operator==(const ConvT &lhs, const ConvT &rhs);
bool operator!=(const ConvT &lhs, const ConvT &rhs);
bool operator==(const OpT &lhs, const OpT &rhs);
bool operator!=(const OpT &lhs, const OpT &rhs);
bool operator==(const NetT &lhs, const NetT &rhs);
bool operator!=(const NetT &lhs, const NetT &rhs);

inline const ::flatbuffers::TypeTable *PoolTypeTable();

inline const ::flatbuffers::TypeTable *ConvTypeTable();

inline const ::flatbuffers::TypeTable *OpTypeTable();

inline const ::flatbuffers::TypeTable *NetTypeTable();

enum OpParameter : uint8_t {
  OpParameter_NONE = 0,
  OpParameter_Conv = 1,
  OpParameter_Pool = 2,
  OpParameter_MIN = OpParameter_NONE,
  OpParameter_MAX = OpParameter_Pool
};

inline const OpParameter (&EnumValuesOpParameter())[3] {
  static const OpParameter values[] = {
    OpParameter_NONE,
    OpParameter_Conv,
    OpParameter_Pool
  };
  return values;
}

inline const char * const *EnumNamesOpParameter() {
  static const char * const names[4] = {
    "NONE",
    "Conv",
    "Pool",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParameter(OpParameter e) {
  if (::flatbuffers::IsOutRange(e, OpParameter_NONE, OpParameter_Pool)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParameter()[index];
}

template<typename T> struct OpParameterTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterTraits<PiNet::Conv> {
  static const OpParameter enum_value = OpParameter_Conv;
};

template<> struct OpParameterTraits<PiNet::Pool> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<typename T> struct OpParameterUnionTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterUnionTraits<PiNet::ConvT> {
  static const OpParameter enum_value = OpParameter_Conv;
};

template<> struct OpParameterUnionTraits<PiNet::PoolT> {
  static const OpParameter enum_value = OpParameter_Pool;
};

struct OpParameterUnion {
  OpParameter type;
  void *value;

  OpParameterUnion() : type(OpParameter_NONE), value(nullptr) {}
  OpParameterUnion(OpParameterUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpParameter_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpParameterUnion(const OpParameterUnion &);
  OpParameterUnion &operator=(const OpParameterUnion &u)
    { OpParameterUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpParameterUnion &operator=(OpParameterUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpParameterUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpParameterUnionTraits<RT>::enum_value;
    if (type != OpParameter_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpParameter type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  PiNet::ConvT *AsConv() {
    return type == OpParameter_Conv ?
      reinterpret_cast<PiNet::ConvT *>(value) : nullptr;
  }
  const PiNet::ConvT *AsConv() const {
    return type == OpParameter_Conv ?
      reinterpret_cast<const PiNet::ConvT *>(value) : nullptr;
  }
  PiNet::PoolT *AsPool() {
    return type == OpParameter_Pool ?
      reinterpret_cast<PiNet::PoolT *>(value) : nullptr;
  }
  const PiNet::PoolT *AsPool() const {
    return type == OpParameter_Pool ?
      reinterpret_cast<const PiNet::PoolT *>(value) : nullptr;
  }
};


inline bool operator==(const OpParameterUnion &lhs, const OpParameterUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_Conv: {
      return *(reinterpret_cast<const PiNet::ConvT *>(lhs.value)) ==
             *(reinterpret_cast<const PiNet::ConvT *>(rhs.value));
    }
    case OpParameter_Pool: {
      return *(reinterpret_cast<const PiNet::PoolT *>(lhs.value)) ==
             *(reinterpret_cast<const PiNet::PoolT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const OpParameterUnion &lhs, const OpParameterUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyOpParameter(::flatbuffers::Verifier &verifier, const void *obj, OpParameter type);
bool VerifyOpParameterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum OpType : int32_t {
  OpType_Conv = 0,
  OpType_Pool = 1,
  OpType_MIN = OpType_Conv,
  OpType_MAX = OpType_Pool
};

inline const OpType (&EnumValuesOpType())[2] {
  static const OpType values[] = {
    OpType_Conv,
    OpType_Pool
  };
  return values;
}

inline const char * const *EnumNamesOpType() {
  static const char * const names[3] = {
    "Conv",
    "Pool",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpType(OpType e) {
  if (::flatbuffers::IsOutRange(e, OpType_Conv, OpType_Pool)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpType()[index];
}

struct PoolT : public ::flatbuffers::NativeTable {
  typedef Pool TableType;
  int32_t padX = 0;
  int32_t padY = 0;
};

struct Pool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoolT NativeTableType;
  typedef PoolBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           verifier.EndTable();
  }
  PoolT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pool> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolBuilder {
  typedef Pool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Pool::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Pool::VT_PADY, padY, 0);
  }
  explicit PoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pool> CreatePool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0) {
  PoolBuilder builder_(_fbb);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  return builder_.Finish();
}

::flatbuffers::Offset<Pool> CreatePool(::flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConvT : public ::flatbuffers::NativeTable {
  typedef Conv TableType;
  int32_t kernelX = 1;
  int32_t kernelY = 1;
};

struct Conv FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConvT NativeTableType;
  typedef ConvBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConvTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNELX = 4,
    VT_KERNELY = 6
  };
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           verifier.EndTable();
  }
  ConvT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConvT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Conv> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConvT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConvBuilder {
  typedef Conv Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNELY, kernelY, 1);
  }
  explicit ConvBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv> CreateConv(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kernelX = 1,
    int32_t kernelY = 1) {
  ConvBuilder builder_(_fbb);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  return builder_.Finish();
}

::flatbuffers::Offset<Conv> CreateConv(::flatbuffers::FlatBufferBuilder &_fbb, const ConvT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpT : public ::flatbuffers::NativeTable {
  typedef Op TableType;
  PiNet::OpType type = PiNet::OpType_Conv;
  PiNet::OpParameterUnion parameter{};
  std::string name{};
  std::vector<int32_t> inputIndexes{};
  std::vector<int32_t> outputIndexes{};
};

struct Op FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OpT NativeTableType;
  typedef OpBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PARAMETER_TYPE = 6,
    VT_PARAMETER = 8,
    VT_NAME = 10,
    VT_INPUTINDEXES = 12,
    VT_OUTPUTINDEXES = 14
  };
  PiNet::OpType type() const {
    return static_cast<PiNet::OpType>(GetField<int32_t>(VT_TYPE, 0));
  }
  PiNet::OpParameter parameter_type() const {
    return static_cast<PiNet::OpParameter>(GetField<uint8_t>(VT_PARAMETER_TYPE, 0));
  }
  const void *parameter() const {
    return GetPointer<const void *>(VT_PARAMETER);
  }
  template<typename T> const T *parameter_as() const;
  const PiNet::Conv *parameter_as_Conv() const {
    return parameter_type() == PiNet::OpParameter_Conv ? static_cast<const PiNet::Conv *>(parameter()) : nullptr;
  }
  const PiNet::Pool *parameter_as_Pool() const {
    return parameter_type() == PiNet::OpParameter_Pool ? static_cast<const PiNet::Pool *>(parameter()) : nullptr;
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTINDEXES);
  }
  const ::flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTINDEXES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_PARAMETER_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           VerifyOpParameter(verifier, parameter(), parameter_type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTINDEXES) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEXES) &&
           verifier.VerifyVector(outputIndexes()) &&
           verifier.EndTable();
  }
  OpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Op> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const PiNet::Conv *Op::parameter_as<PiNet::Conv>() const {
  return parameter_as_Conv();
}

template<> inline const PiNet::Pool *Op::parameter_as<PiNet::Pool>() const {
  return parameter_as_Pool();
}

struct OpBuilder {
  typedef Op Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(PiNet::OpType type) {
    fbb_.AddElement<int32_t>(Op::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_parameter_type(PiNet::OpParameter parameter_type) {
    fbb_.AddElement<uint8_t>(Op::VT_PARAMETER_TYPE, static_cast<uint8_t>(parameter_type), 0);
  }
  void add_parameter(::flatbuffers::Offset<void> parameter) {
    fbb_.AddOffset(Op::VT_PARAMETER, parameter);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Op::VT_NAME, name);
  }
  void add_inputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(Op::VT_INPUTINDEXES, inputIndexes);
  }
  void add_outputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(Op::VT_OUTPUTINDEXES, outputIndexes);
  }
  explicit OpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Op> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Op>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Op> CreateOp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PiNet::OpType type = PiNet::OpType_Conv,
    PiNet::OpParameter parameter_type = PiNet::OpParameter_NONE,
    ::flatbuffers::Offset<void> parameter = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes = 0) {
  OpBuilder builder_(_fbb);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_name(name);
  builder_.add_parameter(parameter);
  builder_.add_type(type);
  builder_.add_parameter_type(parameter_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Op> CreateOpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PiNet::OpType type = PiNet::OpType_Conv,
    PiNet::OpParameter parameter_type = PiNet::OpParameter_NONE,
    ::flatbuffers::Offset<void> parameter = 0,
    const char *name = nullptr,
    const std::vector<int32_t> *inputIndexes = nullptr,
    const std::vector<int32_t> *outputIndexes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndexes__ = inputIndexes ? _fbb.CreateVector<int32_t>(*inputIndexes) : 0;
  auto outputIndexes__ = outputIndexes ? _fbb.CreateVector<int32_t>(*outputIndexes) : 0;
  return PiNet::CreateOp(
      _fbb,
      type,
      parameter_type,
      parameter,
      name__,
      inputIndexes__,
      outputIndexes__);
}

::flatbuffers::Offset<Op> CreateOp(::flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetT : public ::flatbuffers::NativeTable {
  typedef Net TableType;
  std::vector<std::unique_ptr<PiNet::OpT>> oplists{};
  std::vector<std::string> tensorName{};
  std::vector<std::string> outputName{};
  NetT() = default;
  NetT(const NetT &o);
  NetT(NetT&&) FLATBUFFERS_NOEXCEPT = default;
  NetT &operator=(NetT o) FLATBUFFERS_NOEXCEPT;
};

struct Net FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetT NativeTableType;
  typedef NetBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPLISTS = 4,
    VT_TENSORNAME = 6,
    VT_OUTPUTNAME = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PiNet::Op>> *oplists() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PiNet::Op>> *>(VT_OPLISTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tensorName() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TENSORNAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputName() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPLISTS) &&
           verifier.VerifyVector(oplists()) &&
           verifier.VerifyVectorOfTables(oplists()) &&
           VerifyOffset(verifier, VT_TENSORNAME) &&
           verifier.VerifyVector(tensorName()) &&
           verifier.VerifyVectorOfStrings(tensorName()) &&
           VerifyOffset(verifier, VT_OUTPUTNAME) &&
           verifier.VerifyVector(outputName()) &&
           verifier.VerifyVectorOfStrings(outputName()) &&
           verifier.EndTable();
  }
  NetT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Net> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetBuilder {
  typedef Net Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_oplists(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PiNet::Op>>> oplists) {
    fbb_.AddOffset(Net::VT_OPLISTS, oplists);
  }
  void add_tensorName(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensorName) {
    fbb_.AddOffset(Net::VT_TENSORNAME, tensorName);
  }
  void add_outputName(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputName) {
    fbb_.AddOffset(Net::VT_OUTPUTNAME, outputName);
  }
  explicit NetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Net> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Net>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Net> CreateNet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PiNet::Op>>> oplists = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensorName = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputName = 0) {
  NetBuilder builder_(_fbb);
  builder_.add_outputName(outputName);
  builder_.add_tensorName(tensorName);
  builder_.add_oplists(oplists);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Net> CreateNetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PiNet::Op>> *oplists = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tensorName = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputName = nullptr) {
  auto oplists__ = oplists ? _fbb.CreateVector<::flatbuffers::Offset<PiNet::Op>>(*oplists) : 0;
  auto tensorName__ = tensorName ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tensorName) : 0;
  auto outputName__ = outputName ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputName) : 0;
  return PiNet::CreateNet(
      _fbb,
      oplists__,
      tensorName__,
      outputName__);
}

::flatbuffers::Offset<Net> CreateNet(::flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const PoolT &lhs, const PoolT &rhs) {
  return
      (lhs.padX == rhs.padX) &&
      (lhs.padY == rhs.padY);
}

inline bool operator!=(const PoolT &lhs, const PoolT &rhs) {
    return !(lhs == rhs);
}


inline PoolT *Pool::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoolT>(new PoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool::UnPackTo(PoolT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; }
  { auto _e = padY(); _o->padY = _e; }
}

inline ::flatbuffers::Offset<Pool> Pool::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pool> CreatePool(::flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoolT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  return PiNet::CreatePool(
      _fbb,
      _padX,
      _padY);
}


inline bool operator==(const ConvT &lhs, const ConvT &rhs) {
  return
      (lhs.kernelX == rhs.kernelX) &&
      (lhs.kernelY == rhs.kernelY);
}

inline bool operator!=(const ConvT &lhs, const ConvT &rhs) {
    return !(lhs == rhs);
}


inline ConvT *Conv::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConvT>(new ConvT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv::UnPackTo(ConvT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernelX(); _o->kernelX = _e; }
  { auto _e = kernelY(); _o->kernelY = _e; }
}

inline ::flatbuffers::Offset<Conv> Conv::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConvT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Conv> CreateConv(::flatbuffers::FlatBufferBuilder &_fbb, const ConvT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConvT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  return PiNet::CreateConv(
      _fbb,
      _kernelX,
      _kernelY);
}


inline bool operator==(const OpT &lhs, const OpT &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.parameter == rhs.parameter) &&
      (lhs.name == rhs.name) &&
      (lhs.inputIndexes == rhs.inputIndexes) &&
      (lhs.outputIndexes == rhs.outputIndexes);
}

inline bool operator!=(const OpT &lhs, const OpT &rhs) {
    return !(lhs == rhs);
}


inline OpT *Op::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OpT>(new OpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Op::UnPackTo(OpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = parameter_type(); _o->parameter.type = _e; }
  { auto _e = parameter(); if (_e) _o->parameter.value = PiNet::OpParameterUnion::UnPack(_e, parameter_type(), _resolver); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = inputIndexes(); if (_e) { _o->inputIndexes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndexes[_i] = _e->Get(_i); } } else { _o->inputIndexes.resize(0); } }
  { auto _e = outputIndexes(); if (_e) { _o->outputIndexes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndexes[_i] = _e->Get(_i); } } else { _o->outputIndexes.resize(0); } }
}

inline ::flatbuffers::Offset<Op> Op::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOp(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Op> CreateOp(::flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _parameter_type = _o->parameter.type;
  auto _parameter = _o->parameter.Pack(_fbb);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputIndexes = _o->inputIndexes.size() ? _fbb.CreateVector(_o->inputIndexes) : 0;
  auto _outputIndexes = _o->outputIndexes.size() ? _fbb.CreateVector(_o->outputIndexes) : 0;
  return PiNet::CreateOp(
      _fbb,
      _type,
      _parameter_type,
      _parameter,
      _name,
      _inputIndexes,
      _outputIndexes);
}


inline bool operator==(const NetT &lhs, const NetT &rhs) {
  return
      (lhs.oplists.size() == rhs.oplists.size() && std::equal(lhs.oplists.cbegin(), lhs.oplists.cend(), rhs.oplists.cbegin(), [](std::unique_ptr<PiNet::OpT> const &a, std::unique_ptr<PiNet::OpT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.tensorName == rhs.tensorName) &&
      (lhs.outputName == rhs.outputName);
}

inline bool operator!=(const NetT &lhs, const NetT &rhs) {
    return !(lhs == rhs);
}


inline NetT::NetT(const NetT &o)
      : tensorName(o.tensorName),
        outputName(o.outputName) {
  oplists.reserve(o.oplists.size());
  for (const auto &oplists_ : o.oplists) { oplists.emplace_back((oplists_) ? new PiNet::OpT(*oplists_) : nullptr); }
}

inline NetT &NetT::operator=(NetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(oplists, o.oplists);
  std::swap(tensorName, o.tensorName);
  std::swap(outputName, o.outputName);
  return *this;
}

inline NetT *Net::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NetT>(new NetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Net::UnPackTo(NetT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = oplists(); if (_e) { _o->oplists.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->oplists[_i]) { _e->Get(_i)->UnPackTo(_o->oplists[_i].get(), _resolver); } else { _o->oplists[_i] = std::unique_ptr<PiNet::OpT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->oplists.resize(0); } }
  { auto _e = tensorName(); if (_e) { _o->tensorName.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorName[_i] = _e->Get(_i)->str(); } } else { _o->tensorName.resize(0); } }
  { auto _e = outputName(); if (_e) { _o->outputName.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputName[_i] = _e->Get(_i)->str(); } } else { _o->outputName.resize(0); } }
}

inline ::flatbuffers::Offset<Net> Net::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNet(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Net> CreateNet(::flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NetT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _oplists = _o->oplists.size() ? _fbb.CreateVector<::flatbuffers::Offset<PiNet::Op>> (_o->oplists.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->oplists[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _tensorName = _o->tensorName.size() ? _fbb.CreateVectorOfStrings(_o->tensorName) : 0;
  auto _outputName = _o->outputName.size() ? _fbb.CreateVectorOfStrings(_o->outputName) : 0;
  return PiNet::CreateNet(
      _fbb,
      _oplists,
      _tensorName,
      _outputName);
}

inline bool VerifyOpParameter(::flatbuffers::Verifier &verifier, const void *obj, OpParameter type) {
  switch (type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_Conv: {
      auto ptr = reinterpret_cast<const PiNet::Conv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const PiNet::Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParameterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParameter(
        verifier,  values->Get(i), types->GetEnum<OpParameter>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpParameterUnion::UnPack(const void *obj, OpParameter type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpParameter_Conv: {
      auto ptr = reinterpret_cast<const PiNet::Conv *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const PiNet::Pool *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> OpParameterUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpParameter_Conv: {
      auto ptr = reinterpret_cast<const PiNet::ConvT *>(value);
      return CreateConv(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const PiNet::PoolT *>(value);
      return CreatePool(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpParameterUnion::OpParameterUnion(const OpParameterUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpParameter_Conv: {
      value = new PiNet::ConvT(*reinterpret_cast<PiNet::ConvT *>(u.value));
      break;
    }
    case OpParameter_Pool: {
      value = new PiNet::PoolT(*reinterpret_cast<PiNet::PoolT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpParameterUnion::Reset() {
  switch (type) {
    case OpParameter_Conv: {
      auto ptr = reinterpret_cast<PiNet::ConvT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<PiNet::PoolT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpParameter_NONE;
}

inline const ::flatbuffers::TypeTable *OpParameterTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    PiNet::ConvTypeTable,
    PiNet::PoolTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Conv",
    "Pool"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OpTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_INT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    PiNet::OpTypeTypeTable
  };
  static const char * const names[] = {
    "Conv",
    "Pool"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PoolTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "padX",
    "padY"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ConvTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "kernelX",
    "kernelY"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OpTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, 0 },
    { ::flatbuffers::ET_UTYPE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_INT, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    PiNet::OpTypeTypeTable,
    PiNet::OpParameterTypeTable
  };
  static const char * const names[] = {
    "type",
    "parameter_type",
    "parameter",
    "name",
    "inputIndexes",
    "outputIndexes"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NetTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    PiNet::OpTypeTable
  };
  static const char * const names[] = {
    "oplists",
    "tensorName",
    "outputName"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const PiNet::Net *GetNet(const void *buf) {
  return ::flatbuffers::GetRoot<PiNet::Net>(buf);
}

inline const PiNet::Net *GetSizePrefixedNet(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PiNet::Net>(buf);
}

inline bool VerifyNetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PiNet::Net>(nullptr);
}

inline bool VerifySizePrefixedNetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PiNet::Net>(nullptr);
}

inline void FinishNetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PiNet::Net> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PiNet::Net> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<PiNet::NetT> UnPackNet(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<PiNet::NetT>(GetNet(buf)->UnPack(res));
}

inline std::unique_ptr<PiNet::NetT> UnPackSizePrefixedNet(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<PiNet::NetT>(GetSizePrefixedNet(buf)->UnPack(res));
}

}  // namespace PiNet

#endif  // FLATBUFFERS_GENERATED_SSSSSS_PINET_H_
