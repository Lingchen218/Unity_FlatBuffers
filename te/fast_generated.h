// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FAST_COMPANYAGE_H_
#define FLATBUFFERS_GENERATED_FAST_COMPANYAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Companyage {

struct IntArray;
struct IntArrayBuilder;
struct IntArrayT;

struct Gun;
struct GunBuilder;
struct GunT;

bool operator==(const IntArrayT &lhs, const IntArrayT &rhs);
bool operator!=(const IntArrayT &lhs, const IntArrayT &rhs);
bool operator==(const GunT &lhs, const GunT &rhs);
bool operator!=(const GunT &lhs, const GunT &rhs);

inline const ::flatbuffers::TypeTable *IntArrayTypeTable();

inline const ::flatbuffers::TypeTable *GunTypeTable();

struct IntArrayT : public ::flatbuffers::NativeTable {
  typedef IntArray TableType;
  std::vector<int32_t> values{};
};

struct IntArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntArrayT NativeTableType;
  typedef IntArrayBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntArrayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  IntArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IntArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntArrayBuilder {
  typedef IntArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(IntArray::VT_VALUES, values);
  }
  explicit IntArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntArray> CreateIntArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values = 0) {
  IntArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntArray> CreateIntArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return Companyage::CreateIntArray(
      _fbb,
      values__);
}

::flatbuffers::Offset<IntArray> CreateIntArray(::flatbuffers::FlatBufferBuilder &_fbb, const IntArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GunT : public ::flatbuffers::NativeTable {
  typedef Gun TableType;
  std::vector<std::string> serializedGuid{};
  std::vector<std::string> serializedDependencyHash{};
  std::vector<std::unique_ptr<Companyage::IntArrayT>> serializedDenpendencies{};
  GunT() = default;
  GunT(const GunT &o);
  GunT(GunT&&) FLATBUFFERS_NOEXCEPT = default;
  GunT &operator=(GunT o) FLATBUFFERS_NOEXCEPT;
};

struct Gun FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GunT NativeTableType;
  typedef GunBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GunTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZEDGUID = 4,
    VT_SERIALIZEDDEPENDENCYHASH = 6,
    VT_SERIALIZEDDENPENDENCIES = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *serializedGuid() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SERIALIZEDGUID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *serializedDependencyHash() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SERIALIZEDDEPENDENCYHASH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Companyage::IntArray>> *serializedDenpendencies() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Companyage::IntArray>> *>(VT_SERIALIZEDDENPENDENCIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIALIZEDGUID) &&
           verifier.VerifyVector(serializedGuid()) &&
           verifier.VerifyVectorOfStrings(serializedGuid()) &&
           VerifyOffset(verifier, VT_SERIALIZEDDEPENDENCYHASH) &&
           verifier.VerifyVector(serializedDependencyHash()) &&
           verifier.VerifyVectorOfStrings(serializedDependencyHash()) &&
           VerifyOffset(verifier, VT_SERIALIZEDDENPENDENCIES) &&
           verifier.VerifyVector(serializedDenpendencies()) &&
           verifier.VerifyVectorOfTables(serializedDenpendencies()) &&
           verifier.EndTable();
  }
  GunT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GunT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Gun> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GunT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GunBuilder {
  typedef Gun Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_serializedGuid(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serializedGuid) {
    fbb_.AddOffset(Gun::VT_SERIALIZEDGUID, serializedGuid);
  }
  void add_serializedDependencyHash(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serializedDependencyHash) {
    fbb_.AddOffset(Gun::VT_SERIALIZEDDEPENDENCYHASH, serializedDependencyHash);
  }
  void add_serializedDenpendencies(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Companyage::IntArray>>> serializedDenpendencies) {
    fbb_.AddOffset(Gun::VT_SERIALIZEDDENPENDENCIES, serializedDenpendencies);
  }
  explicit GunBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Gun> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Gun>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Gun> CreateGun(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serializedGuid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> serializedDependencyHash = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Companyage::IntArray>>> serializedDenpendencies = 0) {
  GunBuilder builder_(_fbb);
  builder_.add_serializedDenpendencies(serializedDenpendencies);
  builder_.add_serializedDependencyHash(serializedDependencyHash);
  builder_.add_serializedGuid(serializedGuid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Gun> CreateGunDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *serializedGuid = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *serializedDependencyHash = nullptr,
    const std::vector<::flatbuffers::Offset<Companyage::IntArray>> *serializedDenpendencies = nullptr) {
  auto serializedGuid__ = serializedGuid ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*serializedGuid) : 0;
  auto serializedDependencyHash__ = serializedDependencyHash ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*serializedDependencyHash) : 0;
  auto serializedDenpendencies__ = serializedDenpendencies ? _fbb.CreateVector<::flatbuffers::Offset<Companyage::IntArray>>(*serializedDenpendencies) : 0;
  return Companyage::CreateGun(
      _fbb,
      serializedGuid__,
      serializedDependencyHash__,
      serializedDenpendencies__);
}

::flatbuffers::Offset<Gun> CreateGun(::flatbuffers::FlatBufferBuilder &_fbb, const GunT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const IntArrayT &lhs, const IntArrayT &rhs) {
  return
      (lhs.values == rhs.values);
}

inline bool operator!=(const IntArrayT &lhs, const IntArrayT &rhs) {
    return !(lhs == rhs);
}


inline IntArrayT *IntArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IntArrayT>(new IntArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IntArray::UnPackTo(IntArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<IntArray> IntArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IntArray> CreateIntArray(::flatbuffers::FlatBufferBuilder &_fbb, const IntArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IntArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return Companyage::CreateIntArray(
      _fbb,
      _values);
}


inline bool operator==(const GunT &lhs, const GunT &rhs) {
  return
      (lhs.serializedGuid == rhs.serializedGuid) &&
      (lhs.serializedDependencyHash == rhs.serializedDependencyHash) &&
      (lhs.serializedDenpendencies.size() == rhs.serializedDenpendencies.size() && std::equal(lhs.serializedDenpendencies.cbegin(), lhs.serializedDenpendencies.cend(), rhs.serializedDenpendencies.cbegin(), [](std::unique_ptr<Companyage::IntArrayT> const &a, std::unique_ptr<Companyage::IntArrayT> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const GunT &lhs, const GunT &rhs) {
    return !(lhs == rhs);
}


inline GunT::GunT(const GunT &o)
      : serializedGuid(o.serializedGuid),
        serializedDependencyHash(o.serializedDependencyHash) {
  serializedDenpendencies.reserve(o.serializedDenpendencies.size());
  for (const auto &serializedDenpendencies_ : o.serializedDenpendencies) { serializedDenpendencies.emplace_back((serializedDenpendencies_) ? new Companyage::IntArrayT(*serializedDenpendencies_) : nullptr); }
}

inline GunT &GunT::operator=(GunT o) FLATBUFFERS_NOEXCEPT {
  std::swap(serializedGuid, o.serializedGuid);
  std::swap(serializedDependencyHash, o.serializedDependencyHash);
  std::swap(serializedDenpendencies, o.serializedDenpendencies);
  return *this;
}

inline GunT *Gun::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GunT>(new GunT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gun::UnPackTo(GunT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serializedGuid(); if (_e) { _o->serializedGuid.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serializedGuid[_i] = _e->Get(_i)->str(); } } else { _o->serializedGuid.resize(0); } }
  { auto _e = serializedDependencyHash(); if (_e) { _o->serializedDependencyHash.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serializedDependencyHash[_i] = _e->Get(_i)->str(); } } else { _o->serializedDependencyHash.resize(0); } }
  { auto _e = serializedDenpendencies(); if (_e) { _o->serializedDenpendencies.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->serializedDenpendencies[_i]) { _e->Get(_i)->UnPackTo(_o->serializedDenpendencies[_i].get(), _resolver); } else { _o->serializedDenpendencies[_i] = std::unique_ptr<Companyage::IntArrayT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->serializedDenpendencies.resize(0); } }
}

inline ::flatbuffers::Offset<Gun> Gun::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GunT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGun(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Gun> CreateGun(::flatbuffers::FlatBufferBuilder &_fbb, const GunT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GunT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serializedGuid = _o->serializedGuid.size() ? _fbb.CreateVectorOfStrings(_o->serializedGuid) : 0;
  auto _serializedDependencyHash = _o->serializedDependencyHash.size() ? _fbb.CreateVectorOfStrings(_o->serializedDependencyHash) : 0;
  auto _serializedDenpendencies = _o->serializedDenpendencies.size() ? _fbb.CreateVector<::flatbuffers::Offset<Companyage::IntArray>> (_o->serializedDenpendencies.size(), [](size_t i, _VectorArgs *__va) { return CreateIntArray(*__va->__fbb, __va->__o->serializedDenpendencies[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Companyage::CreateGun(
      _fbb,
      _serializedGuid,
      _serializedDependencyHash,
      _serializedDenpendencies);
}

inline const ::flatbuffers::TypeTable *IntArrayTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "values"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GunTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    Companyage::IntArrayTypeTable
  };
  static const char * const names[] = {
    "serializedGuid",
    "serializedDependencyHash",
    "serializedDenpendencies"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const Companyage::Gun *GetGun(const void *buf) {
  return ::flatbuffers::GetRoot<Companyage::Gun>(buf);
}

inline const Companyage::Gun *GetSizePrefixedGun(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Companyage::Gun>(buf);
}

inline const char *GunIdentifier() {
  return "WHAT";
}

inline bool GunBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GunIdentifier());
}

inline bool SizePrefixedGunBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GunIdentifier(), true);
}

inline bool VerifyGunBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Companyage::Gun>(GunIdentifier());
}

inline bool VerifySizePrefixedGunBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Companyage::Gun>(GunIdentifier());
}

inline void FinishGunBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Companyage::Gun> root) {
  fbb.Finish(root, GunIdentifier());
}

inline void FinishSizePrefixedGunBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Companyage::Gun> root) {
  fbb.FinishSizePrefixed(root, GunIdentifier());
}

inline std::unique_ptr<Companyage::GunT> UnPackGun(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Companyage::GunT>(GetGun(buf)->UnPack(res));
}

inline std::unique_ptr<Companyage::GunT> UnPackSizePrefixedGun(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Companyage::GunT>(GetSizePrefixedGun(buf)->UnPack(res));
}

}  // namespace Companyage

#endif  // FLATBUFFERS_GENERATED_FAST_COMPANYAGE_H_
